# Reflection: Challenges in Balancing Stakeholder Needs

 ## Balancing the needs of various parties presented several challenges:

 1. **Conflicting Priorities** 
- Users want a simple and intuitive user interface, while engineers prioritize powerful functionality, which can lead to increased system complexity.

 2. **Security vs. Usability** 
- The Compliance Officer required tight security measures, such as multi-factor authentication (MFA), which may frustrate consumers who desired a seamless login experience.

 3. **Scalability vs. Performance** 
- The system needed to accommodate 1,000+ concurrent users, requiring large server resources. However, the Business Owner preferred cost-effective deployment options.

 4. **Regulatory Compliance vs. Innovation** 
- Complying with GDPR and dietary standards hindered our ability to deliver personalized services without extensive legal evaluations.

4. **Timelines vs. Feature Completeness**
   - Developers struggled with implementing all requested features within project deadlines while ensuring stability.

### How We Addressed These Challenges:
1. **Prioritization Framework** -We used MoSCoW (Must-have, Should-have, Could-have, Won’t-have) to manage feature development.
2. **User Testing & Feedback** - Conducted early usability testing to refine the UI while maintaining security standards.
3. **Incremental Updates** -Adopted Agile for continuous improvement based on stakeholder feedback.

### Assignment 6 Reflections

During this sprint, I faced challenges in setting up the project board, particularly with adding labels and milestones. This process took a significant amount of time, which impacted my overall workflow. Additionally, I encountered an issue where my sprint backlog seemed to be linked to the product backlog, causing tasks to appear in both places when moved.

To resolve this, I decided to start over and create a new project from scratch. This approach helped me organize the backlog properly and ensure that tasks were correctly placed in their respective categories. Through this experience, I learned the importance of carefully structuring the project board from the beginning to avoid unnecessary rework.

Going forward, I will focus on improving my familiarity with project management tools to streamline backlog management and sprint planning. This will help me allocate more time to actual development and testing instead of troubleshooting setup issues.

## Reflection on Project Template Selection and Customization Challenges

### Template Selection Journey

### Initial Challenges
1. **Complexity of Project Requirements**
   - Balancing project-specific needs with template flexibility
   - Identifying the most appropriate workflow representation
   - Translating abstract project requirements into concrete board structure

2. **Template Limitations**
   - Pre-built templates often provide generic workflows
   - Limited customization options
   - Need for manual adaptation to specific project needs

### Decision-Making Process
- Evaluated multiple templates systematically
- Compare workflow stages
- Assessed automation capabilities
- Considered Agile methodology alignment

## Comparative Analysis: GitHub vs. Jira vs. Azure DevOps

### GitHub Projects
#### Strengths
- Seamless GitHub repository integration
- Free for public and private repositories
- Lightweight and intuitive
- Quick setup process

#### Limitations
- Basic customization options
- Limited advanced reporting
- Fewer enterprise-level features

### Jira
#### Strengths
- Highly customizable workflows
- Comprehensive reporting
- Supports multiple project management methodologies

#### Limitations
- Steep learning curve
- Complex configuration
- Potentially overwhelming for smaller projects

### Azure DevOps
#### Strengths
- Comprehensive Application Lifecycle Management
- Advanced pipeline capabilities
- Deep Microsoft ecosystem integration

#### Limitations
- Complex interface
- Higher cost for advanced features
- Less intuitive for smaller teams

## Customization Challenges

### Workflow Representation
- Translating linear development process into board columns
- Ensuring each column adds value to the workflow
- Balancing specificity with flexibility

### Automation Constraints
- Limited built-in automation features
- Manual configuration of workflow rules
- Need for custom scripts or external tools

### Team Adoption
- Ensuring team understanding of new workflow
- Overcoming resistance to new project management approach
- Creating clear guidelines for board usage

## Specific Customization Decisions

### Column Selection Rationale
1. **Backlog**: Capture potential work items
2. **To Do**: Sprint commitment
3. **In Progress**: Active development
4. **Code Review**: Quality assurance checkpoint
5. **Testing**: Comprehensive validation
6. **Done**: Completed work verification

### Labeling Strategy Challenges
- Creating meaningful and consistent labels
- Balancing detail with simplicity
- Ensuring team-wide understanding

## Lessons Learned

### Flexibility is Key
- No single template perfectly fits all projects
- Continuous adaptation is crucial
- Regular review and refinement of workflow

### Practical Recommendations
1. Start with a simple template
2. Gradually introduce complexity
3. Gather team feedback
4. Be prepared to iterate

## Comparative Tool Evaluation Matrix

| Aspect | GitHub Projects | Jira | Azure DevOps |
|--------|----------------|------|--------------|
| **Customization Ease** | Easy | Complex | Moderate |
| **Learning Curve** | Low | High | Moderate |
| **Cost-Effectiveness** | Free | Paid Tiers | Subscription |
| **Integration** | GitHub-Native | Extensive | Microsoft-Centric |
| **Scalability** | Small-Medium | Enterprise | Enterprise |

## Reflection Conclusion

*The journey of template selection is not about finding a perfect solution but about creating a flexible, evolving workflow that adapts to our project's unique needs. Each challenge is an opportunity to refine our approach and improve our project management strategy.*

### Key Takeaways
- Prioritize team workflow over tool features
- Remain adaptable
- Focus on continuous improvement
- Choose tools that enhance, not complicate, collaboration


### Lesson Learnt from Assignment 8

* Understanding System Workflows and Object States
  
This assignment provided valuable insights into the importance of understanding system workflows and object states in software development. Through creating activity diagrams and state transition diagrams, I gained a deeper understanding of how different components of a system interact with each other and how they change state in response to various events.

### Key Takeaways
* Importance of Visual Modeling: Visual modeling using diagrams such as activity diagrams and state transition diagrams is essential in understanding complex system workflows and object states. It helps to identify potential issues and improve the overall design of the system.
  
* System Workflows are Interconnected: System workflows are interconnected, and changes to one workflow can impact others. 
* Understanding these relationships is crucial in designing a cohesive and efficient system.
* Object States are Dynamic: Object states are dynamic and can change in response to various events. Understanding these state changes is essential in designing a system that can adapt to different scenarios.
* Guard Conditions are Crucial: Guard conditions play a critical role in ensuring that transitions between states are valid and consistent. They help to prevent errors and ensure that the system behaves as expected.
  
* Functional Requirements are Key: Functional requirements are essential in guiding the design of system workflows and object states. They help to ensure that the system meets the needs of its users and stakeholders.
Skills Developed

* Analytical Skills: This assignment helped me develop my analytical skills, which are essential in understanding complex system workflows and object states.
* Problem-Solving Skills: By creating activity diagrams and state transition diagrams, I developed my problem-solving skills, which are critical in designing efficient and effective systems.
* Communication Skills: This assignment helped me develop my communication skills, which are essential in conveying complex system designs to stakeholders and team members.
### Application in Future Projects

* The skills and knowledge gained from this assignment will be applied in future projects to:
* Improve System Design: By applying the principles of visual modeling and understanding system workflows and object states, I will be able to design more efficient and effective systems.
* Enhance Problem-Solving Skills: The problem-solving skills developed in this assignment will be applied to tackle complex system design challenges in future projects.
* Communicate Complex Designs: The communication skills developed in this assignment will be used to convey complex system designs to stakeholders and team members, ensuring that everyone is on the same page.

### Reflection on assignment 9

 ## Reflection on Designing the Domain Model and Class Diagram
 
* Designing the domain model and class diagram for the Personalized Meal Planner System was a challenging yet rewarding experience that deepened my understanding of object-oriented design principles and system architecture. 
* The exercise required me to transition from abstract functional requirements to concrete object representations with meaningful relationships and responsibilities.

1. # Challenges Faced
   
* One of the biggest challenges I encountered during the process was finding the right level of abstraction.
* At first, it was tempting to add too many details to each entity in the domain model, such as listing every possible data field a user might interact with. However, this quickly became overwhelming, straying away from the principle of keeping models high-level and focused on key business concepts.
* I had to revisit my model and trim down to only the most relevant attributes and methods, which made the model more focused and maintainable.
* Another area of difficulty was defining relationships between entities.
* For example, initially, I debated whether the relationship between Recipe and Ingredient should be one-to-one or one-to-many.
* I realized that most recipes use multiple ingredients, and some ingredients appear in multiple recipes. Understanding this many-to-many relationship was crucial for accurate modeling and helped me introduce aggregation rather than composition in this case.
  
* I also struggled with method definitions, particularly when deciding which methods belonged to which class.
* For example, whether the method generateShoppingList() should reside in MealPlan or not requires some thought. Eventually, I placed it in the MealPlan class because the shopping list is specifically generated based on the meals within a given plan.
* This helped me reinforce the concept of placing behavior where the related data lives—an essential principle in object-oriented design.

2. # Alignment with Previous Assignments
   
* The class diagram I developed aligns well with earlier assignments involving use case diagrams, state diagrams, and system requirements.
* For instance, the use case “Generate Shopping List” translates directly into the generateShoppingList() method in the MealPlan class.
* Similarly, use cases related to user preferences and dietary restrictions are reflected in the relationships between User, Preference, and DietaryRestriction classes.
* In the state transition diagrams created earlier, we had represented the lifecycle of a MealPlan, from being created, populated with recipes, generating a shopping list, and finally being reviewed.
*  This sequence aligns logically with the method flow in the class diagram. Thus, the current diagram ensures structural consistency with the behavioral and functional models previously developed, offering a holistic view of the system.

3. # Trade-offs Made
   
* During modeling, I had to make several trade-offs to maintain simplicity and clarity. For instance, I considered using inheritance between User types (like BasicUser and PremiumUser), each with different features, but decided against it due to the current system scope not requiring such distinction.
* Instead, I focused on composition and aggregation, which were more appropriate for relationships like MealPlan containing Recipes and ShoppingList containing Ingredients.
* Another trade-off was avoiding the overuse of getters and setters in the diagram to keep it readable. While in an actual implementation, these would be necessary, but they weren’t essential for understanding the system structure and responsibilities at this design stage.

4. # Lessons Learned
   
* This task reinforced several key lessons in object-oriented design. First, I learned the importance of keeping models modular and loosely coupled.
* By ensuring each class has a single responsibility, future changes (such as adding a new dietary constraint) can be made with minimal impact.
* I also understood the value of designing from a user perspective, as it guided me in deciding what functions should be publicly accessible versus internal to the system.

* Moreover, this project helped me appreciate how domain models lay the foundation for the entire system architecture. A well-thought-out domain model and class diagram serve as blueprints that developers, testers, and stakeholders can rely on for consistency and communication.

* Overall, the process of designing and refining both the domain model and the class diagram was a vital exercise in applying theoretical knowledge to a real-world system. It improved my confidence in modeling, clarified my understanding of relationships and responsibilities, and highlighted the importance of aligning structural models with functional requirements.

# Reflection on Open-Source Collaboration Experience

During this assignment, I improved my repository significantly by preparing it for external contributors and undergoing peer review. I created clear and detailed documentation, including a CONTRIBUTING.md with setup instructions, coding standards, and pull request guidelines. I also added a roadmap and labeled issues to help newcomers pick tasks easily. This improved the clarity and usability of the repository, making it easier for contributors to onboard and participate.

The peer feedback helped me identify areas where the documentation could be clearer and encouraged me to ensure consistent issue labeling and better communication of project goals. This iterative feedback loop gave me a real-world experience of managing open-source projects and the importance of transparency and guidance for contributors.

One of the main challenges in onboarding contributors was anticipating the questions and confusion newcomers might face. It required me to think from their perspective and provide comprehensive instructions. Labeling issues appropriately also took time, as I needed to ensure tasks were suitable for first-time contributors without overwhelming them.

Through this process, I learned valuable lessons about open-source collaboration. Clear documentation and structured contribution guidelines are essential to encourage participation and maintain project quality. The process of peer review also highlighted the community aspect of open-source work — collaboration and feedback drive continuous improvement.

Overall, this assignment enhanced my understanding of project management and collaboration in open-source environments, which are crucial skills for professional software development.

